# 프로세스 관리

OS상에서는 수십, 수백, 수천 개의 프로세스를 가동할 수 있다. 이에 비해 물리 서버의 CPU 코어 수는 많아야 수십 개 정도밖에 안 된다. 언제, 어떤 프로세스가 어느 정도의 CPU 코어를 이용할 수 있는지, 
처리 우선순위를 어떻게 결정할 것인지 관리 해야한다.

### OS가 프로그램을 실행하는 구조 

컴퓨터에 설치된 프로그램은 하드디스크에 저장되어 있다. OS가 프로그램을 실행하면 메모리에 해당 프로그램을 할당한다.
메모리에 할당된 프로그램을 '프로세스'라고 한다. 프로세스는 우선순위가 높은 처리에 의해 중단되기도 하는데 이를 '인터럽트'라 한다.

- 프로세스 : 메모리 상에 할당 된 프로그램
- 프로세스의 상태 : 실행 상태, 실행 가능 상태, 대기 상태
- 인터럽트 : 프로세스가 우선순위가 높은 처리에 의해 중단 되는 경우

### 멀티태스킹

OS는 여러 개의 태스크를 동시에 처리하는 능력을 갖고 있는데, 이를 '멀티캐스킹'이라고 한다. 
우리가 파일을 다운받으면서 글을 작성할 수 있는 것도 OS의 멀티태스킹 덕분이다.

'동시에 처리' 라는 것은 실제로 OS가 CPU에게 태스크를 순서대로 할당하는 것이다.
이 순서의 전환이 매우 빠르게 이루어져 '동시'에 움직이고 있는 것처럼 보인다.
이러한 순서를 정하는 것을 '스케줄링' 이라고 한다.

- 태스크 : OS가 CPU에게 의뢰하는 작업
- 시분할 처리 시스템 : 여러 사용자가 한 대의 고성능 컴퓨터를 공유하여 사용할 때 CPU의 사용자에게 순서대로 단시간 할당하는 시스템

### OS의 처리 성능

- 스루풋 : OS의 단위 시간당 처리 능력
- 스풀 : CPU로부터 입출력 장치로 가는 명령을 메모리와 같이 비교적 고속인 기억 장치에 일시적으로 저장하는 것. 프린터는 CPU와 비교해서 처리 속도가 느리므로 스풀을 사용하여 CPU의 처리와 입출력 동작의 처리의 차이를 완화 시킬 수 있다.

### 인터럽트
- 실행 중인 프로그램을 중단하고 우선순위가 높은 다른 프로그램에게 CPU를 할당하는 것
- 내부 인터럽트 : 실행 중인 프로그램이 원인이 되어 일어나는 인터럽트
- 외부 인터럽트 : 주변기기의 입출력 동작이나 하드웨어 고장, 오작동으로 인해 일어나는 인터럽트

### 인터럽트 처리 과정
![image](https://user-images.githubusercontent.com/18106839/135742266-7bf1356e-de21-4d8d-a361-b03ab7eedb03.png)

![image](https://user-images.githubusercontent.com/18106839/135742429-25e7da6c-8a77-4b85-84e6-70141671a0ce.png)

1. Pi 프로세스가 Running 도중 interupt가 걸렸다.
2. 커널이 개입해서 Pi의 Context를 메모리에 있는 PCB에 저장한다. (Context Saving)
3. Interrupt handling이 실행된다. (인터럽트의 원인파악)
4. Interrupt Service가 실행된다. 
5. Interrupt Service가 Terminated되면 CPU가 비게된다.
6. 이 때 Pi가 다시 들어올 수도 있지만 다른 Ready상태의 프로세스가 들어올 수도 있다.
7. PCB에 저장되어 있던 컨텍스트를 프로세스로 복구하는 작업을 Context Restoring이라고 한다.

- 이렇게 실행 중인 프로세스의 context를 저장하고, 앞으로 실행 할 프로세스의 context를 복구하는 것을 **Context Switching** 이라고 한다.
- Context Switching도 비용이 소요되기 때문에 불필요한 Context Switching을 줄이는게 좋다.
  - 가장 대표적인 예는 Thread를 사용하는 것. 
- Context는 프로세스와 관련된 정보들의 집합이다.
  - CPU register context
  - Code & data, stack, PCB

### 프로세스
- 사용자가 프로그램을 실행하면 OS는 그 내용을 메모리상으로 읽어들여 처리한다. 메모리 상에 할당된 프로그램을 '프로세스'라 한다.
- 프로세스 관리 블록(PCB)를 할당 받은 개체
- 멀티태스킹: OS 관리하에서 여러 개의 프로세스가 병행하여 작동하는 것. 태스크를 순서대로 CPU에 할당하고 있기 때문에 여러 개의 태스크가 동시에 작동하고 있는 것처럼 보인다.
- 시분할 처리 시스템 : 여러 사용자가 한 대의 고성능 컴퓨터를 공유하여 사용할 때 CPU의 사용 권한을 사용자에게 순서대로 단시간 할당하는 시스템

### 프로세스 관리
- 프로세스의 상태에는 대기상태, 실행 가능 상태, 실행 상태가 있다.
- 대기 상태: 입출력 동작을 기다리고 있는 상태
- 실행 상태 : 프로세스에 CPU의 사용권한이 할당되어 실행되고 있는 상태
- 실행 가능 상태 : CPU의 사용권할 할당을 기다리고 있는 상태
- 디스패치 : OS가 가장 우선수위가 높은 '실행 가능 상태'의 프로세스에 대해 CPU 사용권한을 할당하는 것
- 프리엠션 : 인터럽트에 의해 CPU 할당을 해제하는 것

### 프로세스 상태

![image](https://user-images.githubusercontent.com/18106839/135741261-d6c40115-5674-49e9-8145-36f6fb72fd9f.png)

#### Created
- 작업(Job)을 커널에 등록
- PCB 할당 및 프로세스 생성
- 커널
   - 가용 메모리 공간 체크 및 프로세스 상태 전이
   - ready로 갈 것인가. suspended ready로 갈 것인가.

#### Ready
- 프로세서(CPU)외에 다른 모든 자원을 할당 받은 상태
  - 프로세서 할당 대기 상태
  - 즉시 실행 가능 상태
- Dispatch
  - Ready state -> running state

#### Running
- 프로세서와 필요한 자원을 모두 할당 받은 상태
- Preemption
  - Running state -> ready states
  - 프로세서를 뺏기는 것.
  - 프로세서 스케줄링에 의해 프리엠션 될 수 있다. (tiem-out, priority changes 등)
- Block/Sleep
  - Running state -> asleep state
  - I/O등 자원 할당 요청

#### Blocked/Asleep
- 프로세서 외에다른 자원을 기다리는 상태
  - 자원 할당은 System call에 의해 이루어짐
- Wake-up
  - Asleep state -> ready state

#### Suspended State
- 메모리를 할당 받지 못한(빼앗긴) 상태
  - Memory image를 swap device에 보관
  - Swap device : 프로그램 정보 저장을 위한 특별한 파일 시스템
  - 커널 또는 사용자에 의해 발생
- Swap-out(suspended)
- Swap-in(resume)

#### Terminated
- 프로세스 수행이 끝난 상태
- 모든 자원 반납 후, 커널 내에 일부 PCB 정보만 남아 있는 상태
  - 이후 프로세스 관리를 위해 정보 수집

### 멀티태스킹의 종류
- 프리엠티브 (선점형 스케줄링) : OS가 실행 가능 상태인 태스크에게 CPU의 사용권한을 할당하고 강제적으로 태스크를 괸리하는 것
- 논프리엠티브 (비선점형 스케줄링): 실행 중인 태스크가 처리를 수행하지 않는 시간을 자발적으로 해제함으로써 다른 태스크와 동시에 실핼할 수 있도록 하는 것
- 논프리엠티브의 경우 CPU를 해제하지 않는 태스크가 있으면 OS 전체의 동작이 정지될 수 있다.

### 프로세스 제어
- 프로그램 상태어 (PSW : Program Status Word) : 인터럽트로 인해 중단된 프로그램의 상태나 연산의 종료 상태를 저장해 두는 '레지스터' (CPU안에 있음)
- 프로세스 제어 블럭 (PCB : Process Control Block) : 각 프로세스의 CPU 상태(컨텍스트)나 프로세스의 상태를 저장해 두는 '메모리 영역'
- 컨텍스트 스위치 : 인터럽트로 인해 프로세스를 전환할 때 OS가 컨텍스트를 PCB에 저장하고 복원하는 것

### PCB가 관리하는 정보
- PID : 프로세스 고유 식별번호
- 스케줄링 정보 : 프로세스 우선순위 등과 같은 스케줄링 관련 정보들
- 프로세스 상태 : 자원 할당, 요청 정보 등
- 메모리 관리 정보 : Page table, segment table등
- 문맥 저장 영역 : 프로세스의 레지스터 상태를 저장하는 공간 등
- 계정 정보 : 자원 사용 시간 등을 관리

### 스케줄링
- OS가 여러 개의 프로세스를 처리할 때 CPU를 할당할 순서를 정하는 것
- 라운드 로빈 방식 : 프로세스가 기다리고 있는 순서대로 일정 시간 씩 CPU를 할당해서 시간이 초과한 프로세스를 맨 마지막으로 돌리는 방식.
- 우선순위 방식 : OS가 프로세스의 우선순위를 정해서 우선순위가 높은 프로세스로 부터 실행해 나가는 방식

### 프로세스의 분기
- fork : 시스템 콜에 의해 프로세스를 복사하는 것. 복사되는 쪽을 부모 프로세스, 복사된 쪽을 자식 프로세스라 한다.
- exec : 자식 프로세스에서 다른 프로그램을 실행하도록 지시하는 것
- wait : 자식 프로세스의 처리가 끝나면 부모 프로세스에게 신호가 보내지므로 이것을 기다림으로써 부모는 자식 프로세스의 종료 까지 대기 wait 시스템 콜에 의해 자식 프로세스에게 마련되었던 PCB메모리가 삭제

아직 잘 와닿지는 않는다.
https://4legs-study.tistory.com/37

### 프로세스의 동기
파일이나 데이터베이스와 같은 자원을 동시에 다룰 때는 주의가 필요하다. 여러 개의 프로세스가 파일이나 데이터베이스에 동시에 액세스하면 데이터의 무결성이 손상될 수 있다.
https://copycode.tistory.com/62

- 크리티컬 섹션 : 
- 배타 제어 : 처리가 끝날 때 까지 하나의 프로세스에게 자원을 독점시키는 것
- 세마포 : 정해진 수 이상의 프로세스가 공유 자원에 동시에 액세스하지 않도록 카운터를 사용하여 제어하는 장치. OS는 세마포의 P조작(획득)과 V조작(해제)로 통행 가능, 통행 불가의 상태를 관리한다.
- 뮤텍스 : 세마포의 카운터 초기값이 1인 경우. 

### 데드락
- 2개의 프로세스가 공유 자원을 잠근 채로 서로의 공유 자원에 액세스 하려고 하면 양쪽 프로세스가 모두 영구적으로 대기 상태가 되는 경우.

#### 데드락의 발생조건
- 상호배제 : 자원은 한번에 한 프로세스만 접근 가능하다.
- 점유대기 : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재
- 비선점 : 다른 프로세스에 할당된 자원을 사용이 끝날 때 까지 강제로 못뺏음
- 순환대기: 프로세스 집합에서 순환형태로 자원을 대기

### 프로세스 간 통신
- 프로세스끼리는 다른 메모리 공간을 참조하기 때문에 서로 어떤 데이터를 갖고 있는지 알 수 없다. OS는 프로세스끼리 통신을 해서 데이터를 주고 받는 기능을 제공한다.
- 메시지 큐 : 프로세스 끼리는 OS의 메시지 기능을 사용하여 1대1로 통신 가능. 메시지를 넣는 장소를 '메시지 큐'라고 한다.
- 파이프 : 여러 개의 프로세스 입출력을 연결하는 장치
- 이름 붙은 파이프 : 파이프에 이름을 붙임으로써 부모 자식 프로세스가 아니어도 프로세스 간 통신을 할 수 있다.

### 공유 메모리
- 프로세스 간에 공통으로 사용할 수 있는 메모리를 작성할 수 있다. 공유메모리를 만들어 프로세스 간의 통신에 사용할 수 있다.
- 공유 메모리: 공유 메모리는 여러 개의 프로세스에서 공통으로 사용할 수 있는 메모리 영역으로 시스템 콜에 의해 작성된다.
- attach : 공유 메모리에 접속하는 것
- detach : 공유 메모리의 접속을 해제 하는 것

### 스레드와 프로세스
- 스레드 : 프로세스 안의 프로그램 실행의 흐름
- 멀티 스레드 : 스레드는 분기가 가능해서 여러 개의 스레드를 동시에 실행가능 한데, 이것을 '멀티스레드'라고 한다.
- 프로세스의 스레드는 같은 메모리 공간을 참조한다.

## REF
- [[Course] Operating System (CPA310) 운영체제 강의 ProcessManagement](https://www.youtube.com/watch?v=MJTr37lgaMA&list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&index=6)
- OS가 보이는 그림책 - 프로세스관리
