# 트랜잭션
- 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 한꺼번에 모두 수행되어야 할 일련의 연산들
- 데이터베이스에서 복구 및 병행 수행 시 처리되어야 하는 작업의 논리적 단위이다.
- 하나의 트랜잭션은 Commit 되거나 Rollback 된다.
- 트랜잭션은 일반적으로 회복의 단위가 된다.

## 트랜잭션의 특성
### 원자성 - Atomicity
- 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 함
- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느 하나라도 에러가 발생하면 트랜잭션 전부가 취소 되어야 함.

### 일관성 - Consistency
- 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함
- 시스팀이 가지고 있는 고정 요소는 트랜잭션 수행전과 트랜 잭션 수행 완료 후의 상태가 같아야함
- 기존의 데이터베이스가 Correct State라면 트랜잭션을 수행하고 난 후에도 Correct State여야 한다.
- Correct State
  - 도메인의 유효범위, 무결성 제약조건 등의 제약조건을 위배하지 않는 정상적인 상태

### 고립성 - Isolation
- 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우, 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음
- 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음

### 영속성, 지속성 - Durability
- 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

## 트랜잭션 전파 레벨
- 현재 진행중인 트랜잭션이 있는데, 새 트랜잭션을 시작하고 싶다면 새로운 커넥션으로 트랜잭션을 시작 가능하다.

### REQUIRED
- Spring @Transactional의 Default 값
- 트랜잭션이 없을 경우, 새로 생성
- 부모 트랜잭션이 존재하면 기존의 트랜잭션 내에서 로직을 실행

### REQUIRES_NEW
- 매번 새로운 트랜잭션을 수행
- 이미 수행되고 있는 트랜잭션이 있다면, 기존의 트랜잭션은 잠시 대기 상태로 두고 자신의 트랜잭션을 실행한다.

### MANDATORY
- 부모 트랜잭션 내에서 실행되며, 없으면 Exception

### SUPPORT
- 부모 트랜잭션이 있다면 부모 트랜잭션으로 실행
- 없을 경우 트랜잭션 없이 동작

### NON_SUPPORT
- 트랜잭션 없이 동작하며
- 부모 트랜잭션이 존재하면 잠시 일시 정지한다.

### NEVER
- 트랜잭션 없이 실행되며, 부모 트랜잭션이 존재하면 Exception

### NESTED
- 해당 메서드가 부모 트랜잭션에서 실행될 경우 별개로 커밋되거나 롤백될수 있음
- 둘러싼 트랜잭션이 없을 경우 REQUIRED와 동일하게 작동
- DB가 SAVEPOINT를 지원해야함.

## 트랜잭션 격리 레벨
### READ_UNCOMMITTED (level0)

- COMMIT이나 ROLLBACK에 상관없이 다른 트랜잭션에서 보여진다.
- 트랜잭션에 처리중인 혹은 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
- 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 B라는 아직 완료되지 않은 데이터를 읽을 수 있다.
- Dirty Read
  - 다른 트랜잭션에서 처리하는 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상

### READ_COMMITED (level1)
- 어떤 트랜잭션 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회할 수 있다.
- 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 해당 데이터에 접근 할 수 없다.
- Non-Repeatable Read
 - 하나의 트랜잭션에서 조회값이 다르게 나오는 현상
 - 트랜잭션1 시작
 - 트랜잭션2 시작
 - 트랜잭션2에서 A의 나이 조회 27살
 - 트랜잭션1에서 A의 나이 27살에서 28살로 바꿈
 - 트랜잭션2에서 28살로 나옴

### REPEATABLE_READ (leve2)
- 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준이다.
- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 shared lock이 걸리므로 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능하다.
- UPDATE 부정합
  - 트랜잭션 1 시작
  - `SELECT * FROM USER WHERE name = "A";`
  - 트랜잭션 2 시작
  - `UPDATE USER SET name = "B" WHERE name = "A"`
  - 트랜잭션 2 커밋
  - `UPDATE USER SET name = "C" WHERE name "A"`
  - 못찾음
- 팬텀리드 발생
  - 한 트랜잭션 내에서 같은 쿼리를 두번 실행 했는데, 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 현상
  - UPDATE문의 영향을 받은 후 부터 출력된다.
  - 트랜잭션 1 시작
  - `SLECT * FROM USER` 0건 조회
  - 트랜잭션 2 시작
  - `INSERT INTO USER VALUES(1, A);`
  - 트랜잭션 2 커밋
  - `UPDATE USER SET name = "B" WHERE id = 1`
  - `SLECT * FROM USER` 1건 조회 (B가 조회됨)

### SERIALIZABLE (leve3)
- 트랜잭션이 완료될 때까지 SLECT 문장이 사용하는 모든 데이터에 shared lock이 걸리므로 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다.



